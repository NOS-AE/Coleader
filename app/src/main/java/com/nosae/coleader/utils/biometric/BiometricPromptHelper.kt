package com.nosae.coleader.utils.biometric

import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import androidx.biometric.BiometricPrompt
import androidx.core.content.ContextCompat
import androidx.core.os.CancellationSignal
import androidx.fragment.app.FragmentActivity
import java.security.*
import java.security.spec.ECGenParameterSpec

/**
 * Create by NOSAE on 2020/6/13
 */
class BiometricPromptHelper(mActivity: FragmentActivity) {

    companion object {
        private const val KEY_NAME = "BiometricPromptHelper"
    }

    private val mBiometricPrompt: BiometricPrompt = BiometricPrompt(
        mActivity,
        ContextCompat.getMainExecutor(mActivity),
        object : BiometricPrompt.AuthenticationCallback() {
            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                callback?.onError(errorCode, errString.toString())
            }

            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                callback?.onSuccess(result)
            }

            override fun onAuthenticationFailed() {
                callback?.onFailed()
            }
        }
    )
    private var callback: BiometricManager.OnBiometriIndentifyCallback? = null
    private lateinit var mCancelSignal: CancellationSignal
    private val mSignature: Signature?
    private val mPromptInfo: BiometricPrompt.PromptInfo = BiometricPrompt.PromptInfo.Builder()
        .setTitle("指纹认证")
        .setDescription("认证指纹以继续下一步操作")
        .setSubtitle("")
        .setNegativeButtonText("取消")
        .build()

    init {
        // val keyPair = generateKeyPair(KEY_NAME)
        // // Send public key part of key pair to the server, this public key will be used for authentication
        // mToBeSignedMessage = StringBuilder()
        //     .append(
        //         Base64.encodeToString(
        //             keyPair!!.public.encoded,
        //             Base64.URL_SAFE
        //         )
        //     )
        //     .append(":")
        //     .append(KEY_NAME)
        //     .append(":") // Generated by the server to protect against replay attack
        //     .append("12345")
        //     .toString()
        mSignature = initSignature(KEY_NAME)
    }

    fun authenticate(cancel: CancellationSignal?, cb: BiometricManager.OnBiometriIndentifyCallback) {
        callback = cb
        mCancelSignal = cancel ?: CancellationSignal()
        mCancelSignal.setOnCancelListener {  }
        val cryptoObjectHelper = CryptoObjectHelper()
        mBiometricPrompt.authenticate(mPromptInfo, cryptoObjectHelper.buildCryptoObject())
    }

    /**
     * Generate NIST P-256 EC Key pair for signing and verification
     * @param keyName
     * @return
     * @throws Exception
     */
    @Throws(Exception::class)
    private fun generateKeyPair(keyName: String): KeyPair? {
        val keyPairGenerator =
            KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore"
            )
        val builder = KeyGenParameterSpec.Builder(
            keyName,
            KeyProperties.PURPOSE_SIGN
        )
            .setAlgorithmParameterSpec(ECGenParameterSpec("secp256r1"))
            .setDigests(
                KeyProperties.DIGEST_SHA256,
                KeyProperties.DIGEST_SHA384,
                KeyProperties.DIGEST_SHA512
            ) // Require the user to authenticate with a biometric to authorize every use of the key
            .setUserAuthenticationRequired(true)
        keyPairGenerator.initialize(builder.build())
        return keyPairGenerator.generateKeyPair()
    }

    @Throws(java.lang.Exception::class)
    private fun getKeyPair(keyName: String): KeyPair? {
        val keyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        if (keyStore.containsAlias(keyName)) { // Get public key
            val publicKey = keyStore.getCertificate(keyName).publicKey
            // Get private key
            val privateKey =
                keyStore.getKey(keyName, null) as PrivateKey
            // Return a key pair
            return KeyPair(publicKey, privateKey)
        }
        return null
    }

    @Throws(java.lang.Exception::class)
    private fun initSignature(keyName: String): Signature? = getKeyPair(keyName)?.let {
        val signature =
            Signature.getInstance("SHA256withECDSA")
        signature.initSign(it.private)
        signature
    }
}